// procedure suggested by the author of the library MyGAL
auto algorithm = FortuneAlgorithm<real>(points); // initialize an instance of Fortune's algorithm
algorithm.construct();                            // construct the diagram
Box<real> localbox{0, 0, 1, 1};
real dist = std::max( Rcpp::max(x)-Rcpp::min(x), Rcpp::max(y)-Rcpp::min(y) ); // tuning the enlargement of the bounding box
algorithm.bound(&localbox, 100);            // Bound the diagram
auto diagram = algorithm.getDiagram(); // Get the constructed diagram
//diagram.intersect(Box<ftype>{0, 0, 2, 2}); // Compute the intersection between the diagram and a box
auto triangulation = diagram.computeTriangulation();
// Extract information and generate the R object
// 1. Construct the matrix of coordinates
Rcpp::NumericMatrix coord(x.size(), 2);
coord(_, 0) = x;
coord(_, 1) = y;
// 2. Construct the matrix mesh (contains Delaunay/voronoi information)
auto halfedges = diagram.getHalfEdges();
std::vector<int> ind1, ind2, bp1, bp2;
std::vector<real>  x1, y1, x2, y2, mx1, my1, mx2, my2;
for(auto it = halfedges.begin(); it->twin != nullptr; it++){
ind1.push_back(it->incidentFace->site->index + 1);
ind2.push_back(it->twin->incidentFace->site->index + 1);
x1.push_back(it->incidentFace->site->point.x);
y1.push_back(it->incidentFace->site->point.y);
x2.push_back(it->twin->incidentFace->site->point.x);
y2.push_back(it->twin->incidentFace->site->point.y);
mx1.push_back(it->destination->point.x);
my1.push_back(it->destination->point.y);
mx2.push_back(it->origin->point.x);
my2.push_back(it->origin->point.y);
bp1.push_back(isboundary(Vector2<real>(it->destination->point.x, it->destination->point.y), localbox));
bp2.push_back(isboundary(Vector2<real>(it->origin->point.x, it->origin->point.y), localbox));
// luckily, twin halfedges are stored one after the other so I just need
// to skip the subsequent halfedge to not include the same information twice
it++;
}
Rcpp::CharacterVector names{"ind1", "ind2", "x1", "y1", "x2", "y2", "mx1", "my1", "mx2", "my2", "bp1", "bp2"};
Rcpp::NumericMatrix mesh(ind1.size(), names.size());
colnames(mesh) = names;
rownames(mesh) = Rcpp::CharacterVector(ind1.size(), "");
std::copy(ind1.cbegin(), ind1.cend(), mesh(_,0).begin());
std::copy(ind2.cbegin(), ind2.cend(), mesh(_,1).begin());
std::copy(x1.cbegin(), x1.cend(), mesh(_,2).begin());
std::copy(y1.cbegin(), y1.cend(), mesh(_,3).begin());
std::copy(x2.cbegin(), x2.cend(), mesh(_,4).begin());
std::copy(y2.cbegin(), y2.cend(), mesh(_,5).begin());
std::copy(mx1.cbegin(), mx1.cend(), mesh(_,6).begin());
std::copy(my1.cbegin(), my1.cend(), mesh(_,7).begin());
std::copy(mx2.cbegin(), mx2.cend(), mesh(_,8).begin());
std::copy(my2.cbegin(), my2.cend(), mesh(_,9).begin());
std::copy(bp1.cbegin(), bp1.cend(), mesh(_,10).begin());
std::copy(bp2.cbegin(), bp2.cend(), mesh(_,11).begin());
// 3. Construct the tri object
// original tri object stores infromation about triangulation in a strange way
// with pointers. I decided to go for a more intuitive way by creating a list
/* the list neighbors is composed by n (number of sites) vector that contain for
* each site the indeces of its neighbours in the Delaunay triangulation
*/
Rcpp::List neighbors(x.size());
for(size_t i=0; i<x.size(); i++){
auto tmp = triangulation.getNeighbors(i); // retrieve information about neighbours
std::for_each(tmp.begin(), tmp.end(), [](size_t& val){ val=val+1; }); // adding one to each index
neighbors[i] = as<Rcpp::IntegerVector>(tmp); // transforming into a Rcpp:IntegerVector
}
Rcpp::List tri = Rcpp::List::create(Rcpp::Named("n") = Rcpp::IntegerVector(1, x.size()),
Rcpp::Named("x") = Rcpp::NumericVector(x),
Rcpp::Named("y") = Rcpp::NumericVector(y),
Rcpp::Named("neighbours") = neighbors);
tri.attr("class") = "tri.mod";
// Construct the final del.vor object
Rcpp::List res = Rcpp::List::create(Rcpp::Named("mesh") = mesh,
Rcpp::Named("x") = coord,
Rcpp::Named("tri.obj") = tri);
res.attr("class") = "delvor";
return res;
}
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 2000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my alpha-shape object retrieved starting from a delvor object has the same
# structure of the one returned by the "ashape" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the ashape matrices don't coincide
not.matching = c()
not.matching.size = c()
not.matching.length = c()
perc.length.diff = c()
eps = 1e-15 # tollerance for confrontation of alpha shape lengths
# up to 1e-15 lengths are the "same"
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
ascpp = RcppAlphahull::ashape(x,y,alpha)
asR = alphahull::ashape(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(asR$edges)[1]!=0 )
perc.length.diff = c(perc.length.diff, abs( (asR$length - ascpp$length)/ascpp$length ))
else
perc.length.diff = c(perc.length.diff, 0)
# checking edges
# same number of edges? if not adding the test to the queue not.matching.size
if(dim(asR$edges)[1]!=dim(ascpp$edges)[1])
not.matching.size = c(not.matching.size, i)
# same edges for the alpha? if not adding the test to the queue of wrong tests
k = 0
if(dim(asR$edges)[1]!=0)
for(j in 1:dim(asR$edges)[1])
k = k + !(search(asR$edges[j,"ind1"], asR$edges[j,"ind2"], ascpp$edges))
if(k > 0)
not.matching = c(not.matching, i)
used.n = c(used.n, n)
}
not.matching.length = which(perc.length.diff >= eps)
rm(list = c("k", "i", "ascpp", "asR", "x", "y"))
not.matching.size
not.matching.length
not.matching
max(perc.length.diff)
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
help(ahull)
library(RcppAlphahull)
