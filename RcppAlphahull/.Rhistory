plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1)
plot(ahcpp, col = c("cyan", "black", "black", "black", "black", "black"), asp = 1, add = T)
plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1, add = T)
plot(vorR, number = F, wpoints = F, wlines = "vor", col = "grey", asp = 1)
# plotting arcs from complement
wrow = which(ahR$complement[,3]>0 & ahR$complement[,"ind"] == 1)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
#Sys.sleep(0.5)
alphahull::arc(ahR$complement[i,1:2], ahR$complement[i,3], ahR$complement[i,17:18], ahR$complement[i,19], col = "red", lty = 2)
points(ahR$complement[i,1],ahR$complement[i,2], pch = 19, col = "red")
}
wrow = which(ahcpp$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
#Sys.sleep(0.5)
alphahull::arc(ahcpp$complement[i,1:2], ahcpp$complement[i,3], ahcpp$complement[i,17:18], ahcpp$complement[i,19], col = "cyan", lty = 2)
points(ahcpp$complement[i,1],ahcpp$complement[i,2], pch = 19, col = "cyan")
}
# plotting circles
wrow = which(ahR$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
# Sys.sleep(0.5)
alphahull::arc(ahR$complement[i,1:2], ahR$complement[i,3], c(0,1), pi, col = "red", lty = 2)
points(ahR$complement[i,1],ahR$complement[i,2], pch = 19, col = "red")
}
wrow = which(ahcpp$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
#Sys.sleep(0.5)
alphahull::arc(ahcpp$complement[i,1:2], ahcpp$complement[i,3], c(0,1), pi, col = "cyan", lty = 2)
points(ahcpp$complement[i,1],ahcpp$complement[i,2], pch = 19, col = "cyan")
}
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(i in 1:dim(tmp)[1])
k = k + !(search(tmp[i,"ind1"], tmp[i,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(i in 1:dim(tmp)[1])
k = k + !(search(tmp[i,"ind1"], tmp[i,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my alpha-shape object retrieved starting from a delvor object has the same
# structure of the one returned by the "ashape" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the ashape matrix don't coincide
not.matching = c()
not.matching.size = c()
not.matching.length = c()
perc.length.diff = c()
eps = 1e-15 # tollerance for confrontation of alpha shape lengths
# up to 1e-15 lengths are the "same"
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
ascpp = RcppAlphahull::ashape(x,y,alpha)
asR = alphahull::ashape(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(asR$edges)[1]!=0 )
perc.length.diff = c(perc.length.diff, abs( (asR$length - ascpp$length)/ascpp$length ))
else
perc.length.diff = c(perc.length.diff, 0)
# checking edges
# same number of edges? if not adding the test to the queue not.matching.size
if(dim(asR$edges)[1]!=dim(ascpp$edges)[1])
not.matching.size = c(not.matching.size, i)
# same edges for the alpha? if not adding the test to the queue of wrong tests
k = 0
if(dim(asR$edges)[1]!=0)
for(i in 1:dim(asR$edges)[1])
k = k + !(search(asR$edges[i,"ind1"], asR$edges[i,"ind2"], ascpp$edges))
if(k > 0)
not.matching = c(not.matching, i)
used.n = c(used.n, n)
}
not.matching.length = which(perc.length.diff >= eps)
rm(list = c("k", "i", "ascpp", "asR", "x", "y"))
not.matching.size
not.matching.length
not.matching
max(perc.length.diff)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my complement object retrieved starting from a delvor object has the same
# structure of the one returned by the "ahull" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search_complement.R")
print("executing test")
# contains those test cases in which the complement matrix don't coincide
not.matching.length = c() # different number of components
not.matching.planes = c() # different planes
not.matching.balls = c() # different balls
eps = 1e-11
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, i)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search_complement(planesR[j,"c1"], planesR[j,"c2"], planesR[j,"r"], planescpp, eps)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
if(dim(ballsR)[1]>0)
for(j in dim(ballsR)[1])
k = k + !search_complement(ballsR[j,"c1"], ballsR[j,"c2"], ballsR[j,"r"], ballscpp, eps)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
# rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my complement object retrieved starting from a delvor object has the same
# structure of the one returned by the "ahull" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search_complement.R")
print("executing test")
# contains those test cases in which the complement matrix don't coincide
not.matching.length = c() # different number of components
not.matching.planes = c() # different planes
not.matching.balls = c() # different balls
eps = 1e-12
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, i)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search_complement(planesR[j,"c1"], planesR[j,"c2"], planesR[j,"r"], planescpp, eps)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
if(dim(ballsR)[1]>0)
for(j in dim(ballsR)[1])
k = k + !search_complement(ballsR[j,"c1"], ballsR[j,"c2"], ballsR[j,"r"], ballscpp, eps)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
# rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my complement object retrieved starting from a delvor object has the same
# structure of the one returned by the "ahull" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search_complement.R")
print("executing test")
# contains those test cases in which the complement matrix don't coincide
not.matching.length = c() # different number of components
not.matching.planes = c() # different planes
not.matching.balls = c() # different balls
eps = 1e-11
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, i)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search_complement(planesR[j,"c1"], planesR[j,"c2"], planesR[j,"r"], planescpp, eps)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
if(dim(ballsR)[1]>0)
for(j in dim(ballsR)[1])
k = k + !search_complement(ballsR[j,"c1"], ballsR[j,"c2"], ballsR[j,"r"], ballscpp, eps)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
# rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
# CONFRONTATION EXAMPLE
set.seed(3)
n = 300
theta = runif(n,0,2*pi)
r = sqrt(runif(n,0.25^2,0.5^2))
x = 0.5+r*cos(theta)
y = 0.5+r*sin(theta)
vorcpp = RcppAlphahull::delvor(x,y)
vorR =alphahull::delvor(x,y)
alpha = 0.1
asR = alphahull::ashape(vorR, alpha = alpha)
ascpp = RcppAlphahull::ashape(vorcpp, alpha = alpha)
ahR = alphahull::ahull(vorR, alpha = alpha)
ahcpp = RcppAlphahull::ahull(vorcpp, alpha = alpha)
par( mfrow = c(1,2))
plot(vorcpp, wlines = "vor", col = c("blue","black","black","black"), pch = 19, main = "RcppAlphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8, asp = 1)
plot(vorR, wlines = "vor", col = c("blue","black","black","black"), pch = 19, main = "alphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8, asp = 1)
x11(width = 960, height = 480)
x11(width = 12, height = 8)
par( mfrow = c(1,2))
plot(vorcpp, wlines = "vor", col = c("blue","black","black","black"), pch = 19, main = "RcppAlphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8, asp = 1)
plot(vorR, wlines = "vor", col = c("blue","black","black","black"), pch = 19, main = "alphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8, asp = 1)
par( mfrow = c(1,2) )
plot(ascpp, col = c("red", "blue"), asp = 1, pch = 19, main = "RcppAlphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8)
plot(asR, col = c("red", "blue"), asp = 1, pch = 19, main = "alphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8)
par( mfrow = c(1,2) )
plot(ahcpp, col = c("red", "blue", "blue"), asp = 1, pch = 19, main = "RcppAlphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8)
plot(ahR, col = c("red", "blue", "blue"), asp = 1, pch = 19, main = "alphahull", xlab = "x", ylab = "y", cex.main = 2, cex.lab = 1.8)
library(RcppAlphahull)
library(RcppAlphahull)
n = 35 # 35
set.seed(353) # 353
x = runif(n)
y = runif(n)
theta = runif(300, 0, 2*pi)
r = runif(300, 0.2, 0.5)
x = r*cos(theta)+0.5
y = r*sin(theta)+0.5
system.time(RcppAlphahull::delvor(x,y))
system.time(alphahull::delvor(x,y))
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x, y)
system.time(plot(vorR, col = c("blue", "red", "black", "blue"), pch = 19, wpoints = T, wlines = 'vor', number = F))
system.time(RcppAlphahull::plot.delvor(vorcpp, col = c("blue", "red", "black", "blue"), pch = 19,
wpoints = T, wlines = 'both', number = F))
source('~/Documenti/ProgettoPACS/test_scripts/Rscript.R', echo=TRUE)
alpha = 0.02
ahR = alphahull::ahull(vorR, alpha = alpha)
ahcpp = RcppAlphahull::ahull(vorcpp, alpha = alpha)
plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1)
plot(ahcpp, col = c("cyan", "black", "black", "black", "black", "black"), asp = 1, add = T)
plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1, add = T)
ahcpp$length
ahR$length
library(RcppAlphahull)
vorcpp = RcppAlphahull::delvor(x,y)
n = 35 # 35
set.seed(353) # 353
x = runif(n)
y = runif(n)
theta = runif(300, 0, 2*pi)
r = runif(300, 0.2, 0.5)
x = r*cos(theta)+0.5
y = r*sin(theta)+0.5
system.time(RcppAlphahull::delvor(x,y))
system.time(alphahull::delvor(x,y))
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x, y)
alpha = 1
asR = alphahull::ashape(vorR, alpha = alpha)
ascpp = RcppAlphahull::ashape(vorcpp, alpha = alpha)
asR$alpha.extremes
ascpp$alpha.extremes
plot(asR, wpoints = T)
plot(ascpp, wpoints = T, col = c("red","black"))
alpha = 0.02
ahR = alphahull::ahull(vorR, alpha = alpha)
ahcpp = RcppAlphahull::ahull(vorcpp, alpha = alpha)
plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1)
plot(ahcpp, col = c("cyan", "black", "black", "black", "black", "black"), asp = 1, add = T)
plot(ahR, col = c("red", "black", "black", "black", "black", "black"), asp = 1, add = T)
plot(vorR, number = F, wpoints = F, wlines = "vor", col = "grey", asp = 1)
# plotting circles
wrow = which(ahR$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
# Sys.sleep(0.5)
alphahull::arc(ahR$complement[i,1:2], ahR$complement[i,3], c(0,1), pi, col = "red", lty = 2)
points(ahR$complement[i,1],ahR$complement[i,2], pch = 19, col = "red")
}
wrow = which(ahcpp$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
#Sys.sleep(0.5)
alphahull::arc(ahcpp$complement[i,1:2], ahcpp$complement[i,3], c(0,1), pi, col = "cyan", lty = 2)
points(ahcpp$complement[i,1],ahcpp$complement[i,2], pch = 19, col = "cyan")
}
library(RcppAlphahull)
library(RcppAlphahull)
# plotting circles
wrow = which(ahR$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
# Sys.sleep(0.5)
alphahull::arc(ahR$complement[i,1:2], ahR$complement[i,3], c(0,1), pi, col = "red", lty = 2)
points(ahR$complement[i,1],ahR$complement[i,2], pch = 19, col = "red")
}
wrow = which(ahcpp$complement[,3]>0)
for(i in wrow){
#invisible(readline(prompt="Press [enter] to continue"))
#Sys.sleep(0.5)
alphahull::arc(ahcpp$complement[i,1:2], ahcpp$complement[i,3], c(0,1), pi, col = "cyan", lty = 2)
points(ahcpp$complement[i,1],ahcpp$complement[i,2], pch = 19, col = "cyan")
}
library(RcppAlphahull)
remove.packages("alphahull", lib="~/R/x86_64-pc-linux-gnu-library/3.4")
remove.packages("RcppAlphahull", lib="~/R/x86_64-pc-linux-gnu-library/3.4")
devtools::install_github("https://github.com/federicoairoldi/ProgettoPACS", subdir = "RcppAlphahull")
devtools::install_github("https://github.com/federicoairoldi/ProgettoPACS", subdir = "RcppAlphahull", dependencies = T)
install.packages('alphahull')
install.packages("alphahull")
devtools::install_github("https://github.com/federicoairoldi/ProgettoPACS", subdir = "RcppAlphahull")
library(RcppAlphahull)
n = 5000
set.seed(1)
x = runif(n,0,10) # sampling the points
y = runif(n,0,10)
alpha = 0.1
system.time(RcppAlphahull::ahull(x,y,alpha))
system.time(alphahull::ahull(x,y,alpha))
system.time(RcppAlphahull::ahull(x,y,alpha))
system.time(alphahull::ahull(x,y,alpha))
n = 500
set.seed(1)
x = runif(n,0,10) # sampling the points
y = runif(n,0,10)
alpha = 0.1
system.time(alphahull::ahull(x,y,alpha))
system.time(RcppAlphahull::ahull(x,y,alpha))
system.time(RcppAlphahull::ahull(x,y,alpha))
system.time(alphahull::ahull(x,y,alpha))
system.time(RcppAlphahull::delvor(x,y))
system.time(alphahull::delvor(x,y))
n
n = 5000
x = runif(n,0,10)
y = runif(n,0,10)
system.time(RcppAlphahull::delvor(x,y))
system.time(alphahull::delvor(x,y))
system.time(alphahull::ahull(vorR, alpha = alpha))
system.time(RcppAlphahull::ahull(vorR, alpha = alpha))
system.time(RcppAlphahull::ahull(vorcpp, alpha = alpha))
