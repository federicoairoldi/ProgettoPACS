#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the complement matrix don't coincide
not.matching.length = c() # different number of components
not.matching.planes = c() # different planes
not.matching.balls = c() # different balls
n.test = 10
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, 1)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search(planesR[j,"ind1"], planesR[j,"ind2"], planescpp)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
for(i in dim(ballsR)[1])
k = k + !search(ballsR[i,"ind1"], ballsR[i,"ind2"], ballscpp)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, 1)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search(planesR[j,"ind1"], planesR[j,"ind2"], planescpp)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
for(i in dim(ballsR)[1])
k = k + !search(ballsR[i,"ind1"], ballsR[i,"ind2"], ballscpp)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my complement object retrieved starting from a delvor object has the same
# structure of the one returned by the "ahull" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the complement matrix don't coincide
not.matching.length = c() # different number of components
not.matching.planes = c() # different planes
not.matching.balls = c() # different balls
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
complementcpp = RcppAlphahull::complement(x,y,alpha)
complementR = alphahull::complement(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(complementcpp)[1]!=dim(complementR)[1] )
not.matching.length = c(not.matching.length, 1)
k = 0
for(type in c(-1, -2, -3, -4)){
planesR = complementR[which(complementR[,"r"] == type),]
planescpp = complementcpp[which(complementcpp[,"r"] == type),]
if(dim(planesR)[1]>0)
for(j in dim(planesR)[1])
k = k + !search(planesR[j,"ind1"], planesR[j,"ind2"], planescpp)
}
if(k > 0)
not.matching.planes = c(not.matching.planes, i)
k = 0
ballsR = complementR[which(complementR[,"r"] > 0),]
ballscpp = complementcpp[which(complementcpp[,"r"] > 0),]
for(i in dim(ballsR)[1])
k = k + !search(ballsR[i,"ind1"], ballsR[i,"ind2"], ballscpp)
if(k > 0)
not.matching.balls = c(not.matching.balls, i)
used.n = c(used.n, n)
}
rm(list = c("k", "i", "complementR", "complementcpp", "x", "y"))
not.matching.length
not.matching.planes
not.matching.balls
help(complement)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests the performances of the package alphahull with respect to the
# performances of the R/C++ hybrid package RcppAlphahull for the function ashape
#
# by setting a different number of sites the script computes the Voronoi diagram and Delanuay tesselation
# of n randomized point of R2 in [0;1]x[0;1] (if one likes, he can change the seed) and next computes the
# alpha shape for a random value of alpha.
#
# NB: this script compares speed of constructions of the alpha shape, it doesn't include the time spent to
# compute the Voronoi tesselation/Delanuay triangulation.
require(rbenchmark)
require(alphahull)
require(RcppAlphahull)
set.seed(7658)
n.nodes = c( seq(100,900,by=100),
seq(1000,9000,by=1000))
relative = c()
RTime = c()
CppTime = c()
for(n in n.nodes){
print(paste("Simulation:",n))
x = runif(n)
y = runif(n)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::ashape(vorcpp,alpha),
"R" = alphahull::ashape(vorR,alpha),
replications = 1)
CppTime = rbind(CppTime, res[which(res[,"test"] == "Cpp"), c("elapsed", "user.self", "sys.self")])
RTime = rbind(RTime, res[which(res[,"test"] == "R"), c("elapsed", "user.self", "sys.self")])
relative = c(relative, res[which(res[,"test"] == "R"), c("relative")])
}
tmp = cbind(CppTime, RTime)
Cpp.User = tmp[,2]
R.User = tmp[,5]
transfCpp = n.nodes*log(n.nodes, 2)
transfR = (n.nodes*log(n.nodes, 2))^2
fit.cpp = lm(Cpp.User ~ 0 + transfCpp)
summary(fit.cpp)
fit.R = lm(R.User ~ 0 + transfR)
summary(fit.R)
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
R.User/Cpp.User
alpha
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests the performances of the package alphahull with respect to the
# performances of the R/C++ hybrid package RcppAlphahull for the function ashape
#
# by setting a different number of sites the script computes the Voronoi diagram and Delanuay tesselation
# of n randomized point of R2 in [0;1]x[0;1] (if one likes, he can change the seed) and next computes the
# alpha shape for a random value of alpha.
#
# NB: this script compares speed of constructions of the alpha shape, it doesn't include the time spent to
# compute the Voronoi tesselation/Delanuay triangulation.
require(rbenchmark)
require(alphahull)
require(RcppAlphahull)
set.seed(7658)
n.nodes = c( seq(100,900,by=100),
seq(1000,9000,by=1000))
relative = c()
RTime = c()
CppTime = c()
for(n in n.nodes){
print(paste("Simulation:",n))
x = runif(n)
y = runif(n)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::ashape(vorcpp,alpha),
"R" = alphahull::ashape(vorR,alpha),
replications = 1)
CppTime = rbind(CppTime, res[which(res[,"test"] == "Cpp"), c("elapsed", "user.self", "sys.self")])
RTime = rbind(RTime, res[which(res[,"test"] == "R"), c("elapsed", "user.self", "sys.self")])
relative = c(relative, res[which(res[,"test"] == "R"), c("relative")])
}
tmp = cbind(CppTime, RTime)
Cpp.User = tmp[,2]
R.User = tmp[,5]
transfCpp = n.nodes*log(n.nodes, 2)
transfR = (n.nodes*log(n.nodes, 2))^2
fit.cpp = lm(Cpp.User ~ 0 + transfCpp)
summary(fit.cpp)
fit.R = lm(R.User ~ 0 + transfR)
summary(fit.R)
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
R.User/Cpp.User
tmp
res
RcppAlphahull::ashape(vorcpp,alpha)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::ashape(vorcpp,alpha),
"R" = alphahull::ashape(vorR,alpha),
replications = 1)
res = benchmark("Cpp" = RcppAlphahull::ashape(vorcpp, alpha = alpha),
"R" = alphahull::ashape(vorR, alpha = alpha),
replications = 1)
res
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests the performances of the package alphahull with respect to the
# performances of the R/C++ hybrid package RcppAlphahull for the function ashape
#
# by setting a different number of sites the script computes the Voronoi diagram and Delanuay tesselation
# of n randomized point of R2 in [0;1]x[0;1] (if one likes, he can change the seed) and next computes the
# alpha shape for a random value of alpha.
#
# NB: this script compares speed of constructions of the alpha shape, it doesn't include the time spent to
# compute the Voronoi tesselation/Delanuay triangulation.
require(rbenchmark)
require(alphahull)
require(RcppAlphahull)
set.seed(7658)
n.nodes = c( seq(100,900,by=100),
seq(1000,9000,by=1000))
relative = c()
RTime = c()
CppTime = c()
for(n in n.nodes){
print(paste("Simulation:",n))
x = runif(n)
y = runif(n)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::ashape(vorcpp, alpha = alpha),
"R" = alphahull::ashape(vorR, alpha = alpha),
replications = 1)
CppTime = rbind(CppTime, res[which(res[,"test"] == "Cpp"), c("elapsed", "user.self", "sys.self")])
RTime = rbind(RTime, res[which(res[,"test"] == "R"), c("elapsed", "user.self", "sys.self")])
relative = c(relative, res[which(res[,"test"] == "R"), c("relative")])
}
tmp = cbind(CppTime, RTime)
Cpp.User = tmp[,2]
R.User = tmp[,5]
transfCpp = n.nodes*log(n.nodes, 2)
transfR = (n.nodes*log(n.nodes, 2))^2
fit.cpp = lm(Cpp.User ~ 0 + transfCpp)
summary(fit.cpp)
fit.R = lm(R.User ~ 0 + transfR)
summary(fit.R)
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
R.User/Cpp.User
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests the performances of the package alphahull with respect to the
# performances of the R/C++ hybrid package RcppAlphahull for the function ashape
#
# by setting a different number of sites the script computes the Voronoi diagram and Delanuay tesselation
# of n randomized point of R2 in [0;1]x[0;1] (if one likes, he can change the seed) and next computes the
# alpha hull complement for a random value of alpha.
#
# NB: this script compares speed of constructions of the alpha shape, it doesn't include the time spent to
# compute the Voronoi tesselation/Delanuay triangulation.
require(rbenchmark)
require(alphahull)
require(RcppAlphahull)
set.seed(7658)
n.nodes = c( seq(100,900,by=100),
seq(1000,9000,by=1000))
relative = c()
RTime = c()
CppTime = c()
for(n in n.nodes){
print(paste("Simulation:",n))
x = runif(n)
y = runif(n)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::complement(vorcpp, alpha = alpha),
"R" = alphahull::complement(vorR, alpha = alpha),
replications = 1)
CppTime = rbind(CppTime, res[which(res[,"test"] == "Cpp"), c("elapsed", "user.self", "sys.self")])
RTime = rbind(RTime, res[which(res[,"test"] == "R"), c("elapsed", "user.self", "sys.self")])
relative = c(relative, res[which(res[,"test"] == "R"), c("relative")])
}
tmp = cbind(CppTime, RTime)
Cpp.User = tmp[,2]
R.User = tmp[,5]
transfCpp = n.nodes*log(n.nodes, 2)
transfR = (n.nodes*log(n.nodes, 2))^2
fit.cpp = lm(Cpp.User ~ 0 + transfCpp)
summary(fit.cpp)
fit.R = lm(R.User ~ 0 + transfR)
summary(fit.R)
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
R.User/Cpp.User
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests the performances of the package alphahull with respect to the
# performances of the R/C++ hybrid package RcppAlphahull for the function ashape
#
# by setting a different number of sites the script computes the Voronoi diagram and Delanuay tesselation
# of n randomized point of R2 in [0;1]x[0;1] (if one likes, he can change the seed) and next computes the
# alpha hull complement for a random value of alpha.
#
# NB: this script compares speed of constructions of the alpha shape, it doesn't include the time spent to
# compute the Voronoi tesselation/Delanuay triangulation.
require(rbenchmark)
require(alphahull)
require(RcppAlphahull)
set.seed(7658)
n.nodes = c( seq(100,900,by=100),
seq(1000,9000,by=1000),
seq(10000,60000,by=10000))
relative = c()
RTime = c()
CppTime = c()
for(n in n.nodes){
print(paste("Simulation:",n))
x = runif(n)
y = runif(n)
alpha = runif(1)
vorcpp = RcppAlphahull::delvor(x, y)
vorR = alphahull::delvor(x, y)
res = benchmark("Cpp" = RcppAlphahull::complement(vorcpp, alpha = alpha),
"R" = alphahull::complement(vorR, alpha = alpha),
replications = 1)
CppTime = rbind(CppTime, res[which(res[,"test"] == "Cpp"), c("elapsed", "user.self", "sys.self")])
RTime = rbind(RTime, res[which(res[,"test"] == "R"), c("elapsed", "user.self", "sys.self")])
relative = c(relative, res[which(res[,"test"] == "R"), c("relative")])
}
tmp = cbind(CppTime, RTime)
Cpp.User = tmp[,2]
R.User = tmp[,5]
transfCpp = n.nodes*log(n.nodes, 2)
transfR = (n.nodes*log(n.nodes, 2))^2
fit.cpp = lm(Cpp.User ~ 0 + transfCpp)
summary(fit.cpp)
fit.R = lm(R.User ~ 0 + transfR)
summary(fit.R)
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
R.User/Cpp.User
CppTime
tmp
N = 15
x11()
# tiff("speed.tiff")
matplot(n.nodes[1:N], cbind(Cpp.User[1:N], R.User[1:N]), type = "l", col = c("blue", "red"), lty = 1,
xlab = "Number of nodes", ylab = "CPU time")
lines(n.nodes[1:N], fit.cpp$fitted.values[1:N], col = "green", lty = 2)
lines(n.nodes[1:N], fit.R$fitted.values[1:N], col = "orange", lty = 2)
legend("topleft", legend = c("C++", "R", "nlogn"), fill = c("blue", "red", "green"), )
#graphics.off()
Cpp.User
R.User
fun = delvor
fun
fun = RcppAlphahull::delvor
fun
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my alpha-shape object retrieved starting from a delvor object has the same
# structure of the one returned by the "ashape" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the ashape matrix don't coincide
not.matching = c()
not.matching.size = c()
not.matching.length = c()
perc.length.diff = c()
eps = 1e-15 # tollerance for confrontation of alpha shape lengths
# up to 1e-15 lengths are the "same"
n.test = 5000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
ascpp = RcppAlphahull::ashape(x,y,alpha)
asR = alphahull::ashape(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(asR$edges)[1]!=0 )
perc.length.diff = c(perc.length.diff, abs( (asR$length - ascpp$length)/ascpp$length ))
else
perc.length.diff = c(perc.length.diff, 0)
# checking edges
# same number of edges? if not adding the test to the queue not.matching.size
if(dim(asR$edges)[1]!=dim(ascpp$edges)[1])
not.matching.size = c(not.matching.size, i)
# same edges for the alpha? if not adding the test to the queue of wrong tests
k = 0
if(dim(asR$edges)[1]!=0)
for(i in 1:dim(asR$edges)[1])
k = k + !(search(asR$edges[i,"ind1"], asR$edges[i,"ind2"], ascpp$edges))
if(k > 0)
not.matching = c(not.matching, i)
used.n = c(used.n, n)
}
not.matching.length = which(perc.length.diff >= eps)
rm(list = c("k", "i", "ascpp", "asR", "x", "y"))
not.matching.size
not.matching.length
not.matching
library(RcppAlphahull)
library(RcppAlphahull)
